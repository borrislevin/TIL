// 2_스마트포인터3_1
#include <iostream>

int main()
{
	// 핵심 1. 포인터의 필요성
	// 크기 변경이 가능한 배열을 사용하고 싶다.
//	int x[10] = { 0 };	// 크기 변경 불가!!

	int* p = new int[10]; // 또는 malloc, 
	
	// C/C++ 에서는 "다양한 이유"로 포인터가 반드시 필요 하다.
	//-------------------------------------------------------------

	// 핵심 2. 포인터의 대표적인 문제점 3가지

	// A. 메모리 누수 ( 할당하고 삭제 하지 않은 것 )
	int* p1 = new int;

	// B. Dangling Pointer ( 지워졌는데, 모르고 해당 주소를 사용하는 것)
	int* p2 = new int;
	int* p3 = p2;

	delete p2;		// 자원 삭제

	if (p3 != nullptr)	// p3가 0은 아닌 주소를 가지고 있지만
						// 이미 그곳의 메모리는 파괴 되었다
		*p3 = 10; // runtime error

	// C. double delete
	int* p4 = new int;
	int* p5 = p4;
	delete p4;
	delete p5;  // 이미 지웠는데.. 다시 지우는 경우.

	// C++ 스마트 포인터의 목표..
	// : 위의 모든 문제를 해결해 보자.
	//   아래 코드는 위의 3가지 문제가 나타나지 않는다.
	Ptr<int> p1(new int);
	Ptr<int> p2 = p1;  // 참조계수로 관리.

	// 대신, 스마트 포인터는 다른 문제가 있다!!!- 뒤쪽예제.

}






